SANDBOX
http://eloquentjavascript.net/code/#2

- Undefined vs null

Automatic Type Conversion
    console.log(8 * null)
    // ▹ 0
    console.log("5" - 1)
    // ▹ 4
    console.log("5" + 1)
    // ▹ 51
    console.log("five" * 2)
    // ▹ NaN
    console.log(false == 0)
    // ▹ true
When an operator is applied to the “wrong” type of value, JavaScript will quietly convert that value to the type it wants, using a set of rules that often aren’t what you want or expect. 

console.log(null == undefined);
// ▹ true
console.log(null == 0);
// ▹ false

The rules for converting strings and numbers to Boolean values state that 0, NaN, and the empty string ("") count as false, while all the other values count as true. Because of this, expressions like 0 == false and "" == false are also true. For cases like this, where you do not want any automatic type conversions to happen, there are two extra operators: === and !==. The first tests whether a value is precisely equal to the other, and the second tests whether it is not precisely equal. So "" === false is false as expected.

The || operator, for example, will return the value to its left when that can be converted to true and will return the value on its right otherwise. This conversion works as you’d expect for Boolean values and should do something analogous for values of other types.
console.log(null || "user")
// ▹ user
console.log("Karl" || "user")
// ▹ Karl


Dialog Functions
- You can ask the user an OK/Cancel question using confirm

- prompt function can be used to ask an “open” question. The first argument is the question, the second one is the text that the user starts with. A line of text can be typed into the dialog window, and the function will return this text as a string.


FUNCTIONS
JavaScript is extremely broad-minded about the number of arguments you pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters simply get assigned the value undefined.

function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

var twice = multiplier(2);
console.log(twice(5));
// ▹ 10

Thinking about programs like this takes some practice. A good mental model is to think of the function keyword as “freezing” the code in its body and wrapping it into a package (the function value). So when you read return function(...) {...}, think of it as returning a handle to a piece of computation, frozen for later use.

In the example, multiplier returns a frozen chunk of code that gets stored in the twice variable. The last line then calls the value in this variable, causing the frozen code (return number * factor;) to be activated. It still has access to the factor variable from the multiplier call that created it, and in addition it gets access to the argument passed when unfreezing it, 5, through its number parameter.

// Create a function value f
var f = function(a) {
  console.log(a + 2);
};

// Declare g to be a function
function g(a, b) {
  return a * b * 3.5;
}

ARRAYS
var mack = [];
mack.push("Mack");
mack.push("the", "Knife");
console.log(mack);
// ▹ ["Mack", "the", "Knife"]
console.log(mack.join(" "));
// ▹ Mack the Knife
console.log(mack.pop());
// ▹ Knife
console.log(mack);
// ▹ ["Mack", "the"]

DELETE function

var anObject = {left: 1, right: 2};
console.log(anObject.left);
// ▹ 1
delete anObject.left;
console.log(anObject.left);
// ▹ undefined
console.log("left" in anObject);
// ▹ false
console.log("right" in anObject);
// ▹ true

forEach, for... in

var journal = [
  {events: ["work", "touched tree", "pizza",
            "running", "television"],
   squirrel: false},
  {events: ["work", "ice cream", "cauliflower",
            "lasagna", "touched tree", "brushed teeth"],
   squirrel: false},
  {events: ["weekend", "cycling", "break",
            "peanuts", "beer"],
   squirrel: true},
  /* and so on... */
];
journal.forEach( element => { 
  //console.log(element)
  for (let e in element) {
    console.log(e + ": " +element[e]);
  }
});

https://codeburst.io/javascript-the-difference-between-foreach-and-for-in-992db038e4c2

MUTABILITY
When we have two numbers, 120 and 120, we can consider them precisely the same number, whether or not they refer to the same physical bits. But with objects, there is a difference between having two references to the same object and having two different objects that contain the same properties. Consider the following code:var object1 = {value: 10};var object2 = object1;var object3 = {value: 10};console.log(object1 == object2);// ▹ trueconsole.log(object1 == object3);// ▹ falseobject1.value = 15;console.log(object2.value);// ▹ 15console.log(object3.value);// ▹ 10


